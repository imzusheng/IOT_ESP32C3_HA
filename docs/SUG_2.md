## 架构优劣势

### 优势

1. **高度解耦**

   * 所有模块通过 `EventBus` 通信，互不直接依赖，便于单独调试、替换或扩展。
2. **可视化清晰**

   * Mermaid 图和分层设计，把启动、依赖、事件流都画清楚，利于团队理解和维护。
3. **依赖注入模式**

   * `MainController` 统一管理依赖，模块生命周期清晰，避免到处 `import`。
4. **状态机驱动**

   * `SystemFSM` 明确控制系统生命周期，方便实现容错和状态回滚。
5. **资源优化意识**

   * 有对象池、静态缓存、GC监控，对 ESP32-C3 这种 200KB RAM 的设备很重要。
6. **可扩展性**

   * 新功能只需增加事件类型和订阅方，不必大改现有代码。

### 劣势 / 潜在问题

1. **EventBus 单点瓶颈**

   * 事件调度完全依赖 `EventBus`，队列满或延迟就会卡全局。
2. **事件风暴风险**

   * 某些状态（如 SENSOR\_DATA 高频上报）可能触发大量事件，导致调度阻塞。
3. **内存和GC压力**

   * 队列消息对象过多时，会瞬间吃掉 RAM，引发 `MEMORY_CRITICAL`。
4. **调试难度高**

   * 事件是异步分发的，追踪调用链不如同步调用直观，容易调不出问题。
5. **状态机复杂度**

   * 状态多且转移频繁时，FSM 代码可能变得难维护。
6. **启动链路长**

   * 启动要走多个依赖注入和初始化步骤，在掉电重启场景可能影响上线速度。

---

## EventBus 队列满的原因

ESP32-C3 上的 MicroPython 或自研 EventBus 里，调度队列（通常是 `list` 或 `uasyncio.Queue`）如果满，常见原因有：

* **生产快 / 消费慢**：比如 SENSOR\_DATA 50ms 一次，但处理函数 200ms 才完成。
* **事件无优先级**：低价值事件（LOG\_DEBUG）和高优先级事件（MEMORY\_CRITICAL）排在同一队列里。
* **阻塞型订阅者**：某个 handler 内部用 `time.sleep()` 或阻塞 IO，卡住整个消费 loop。
* **队列容量过小**：默认长度不足以承受短期事件峰值。

---

## 解决思路 & 架构优化建议

### 1. **事件分级 / 多通道队列**

* 把 `EventBus` 拆为 **高优先级队列**（系统错误、心跳、网络连接）和 **普通队列**（日志、传感器数据）。
* 高优先级队列先消费，保证关键事件不被挤掉。

```python
EventBus.publish(event, priority=HIGH)
EventBus.publish(event, priority=LOW)
```

### 2. **丢弃或聚合低价值事件**

* 高频 SENSOR\_DATA 可做采样或合并（比如每 10 条取均值再发一次）。
* DEBUG 日志事件直接在本地缓冲区累积，不必全部丢给 EventBus。

### 3. **异步 + 背压机制**

* 消费端用 `uasyncio` 异步执行，避免阻塞。
* `publish()` 检测队列满时，低优先级事件直接丢弃或覆盖旧的。

### 4. **热点事件直连**

* 极高频、对延迟敏感的事件（如 LED 状态）绕过 EventBus，直接函数调用，减少中间开销。

### 5. **环形缓冲 / 对象池复用事件对象**

* 用固定大小 `deque`（或循环数组）存事件，满了自动覆盖旧数据。
* 结合 `ObjectPool` 避免频繁分配/回收事件对象，降低 GC 压力。

### 6. **消费性能监控**

* 在 EventBus 中记录事件处理耗时和队列长度，发现 handler 慢时报警。

```python
if handler_time > 50: logger.warn("Slow handler: %s", name)
```

### 7. **状态机直接触发关键动作**

* 某些 FSM 转移可以直调模块 API，不必一律发事件，减少 EventBus 负担。