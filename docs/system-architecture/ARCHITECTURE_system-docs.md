# ESP32-C3 IoT 系统架构文档

## 架构概览

本项目采用事件驱动的模块化架构，专门为ESP32-C3的资源限制环境设计，确保系统在有限内存和处理能力下保持稳定可靠的运行。

### 核心设计原则

1. **事件驱动解耦**：模块间通过EventBus松耦合通信，避免直接依赖
2. **状态机驱动**：系统核心逻辑通过状态机管理，确保状态转换的可预测性
3. **资源节约**：针对ESP32-C3的264KB内存限制优化设计
4. **容错恢复**：多层错误处理和自动恢复机制

## 系统架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                         主控制器 (MainController)                │
│                     配置管理、生命周期协调                       │
└─────────────────────┬───────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────┐
│              事件总线 (EventBus)          │
│            系统消息中枢与解耦层            │
└─────┬─────────────────────┬─────────────┘
      │                     │
┌─────┴──────┐        ┌─────┴──────────┐
│状态机(FSM) │        │网络管理器(Net) │
│核心状态控制│        │连接流程编排    │
└─────┬──────┘        └─────┬──────────┘
      │                     │
      ├─ LED控制器           ├─ WiFi管理器
      ├─ 看门狗管器          ├─ MQTT控制器
      └─ 错误处理            └─ NTP管理器
```

## 核心模块职责

### 1. MainController (主控制器)
- **位置**: `app/main.py`
- **职责**:
  - 系统初始化：配置加载、日志设置、模块装配
  - 生命周期管理：启动、运行、关闭流程协调
  - 主循环驱动：定期调用各组件的update方法
  - 系统监控：内存、状态统计与垃圾回收

### 2. EventBus (事件总线)
- **位置**: `app/lib/lock/event_bus.py`
- **职责**:
  - 事件发布与订阅管理
  - 模块间消息传递的统一接口
  - 事件队列与异步处理
  - 系统解耦的核心基础设施

### 3. FSM (状态机核心)
- **位置**: `app/fsm/core.py`
- **职责**:
  - 系统状态演进：BOOT → INIT → CONNECTING → RUNNING → ERROR
  - 事件响应：订阅关键系统事件并触发状态转换
  - 外设控制：LED状态指示、看门狗管理
  - 错误恢复：系统异常时的自动重启机制

### 4. NetworkManager (网络管理器)
- **位置**: `app/net/network_manager.py`
- **职责**:
  - 网络连接流程编排：WiFi → NTP → MQTT
  - 网络状态监控与事件上报
  - 连接状态聚合查询接口
  - 网络重连与故障处理

## 网络子系统架构

### WiFi管理器
- **位置**: `app/net/wifi.py`
- **功能**: 网络扫描、连接管理、状态检查
- **特性**: RSSI信号强度排序，为上层提供最优连接选择支持

### MQTT控制器
- **位置**: `app/net/mqtt.py`
- **功能**: MQTT连接、消息发布/订阅、状态管理
- **特性**: 轻量化实现，重连策略委托给上层NetworkManager

### NTP管理器
- **位置**: `app/net/ntp.py`
- **功能**: 网络时间同步、时间状态缓存
- **特性**: 一次性同步策略，重试逻辑由上层统一控制

## 事件流转机制

### 主要事件类型
- `WIFI_STATE_CHANGE`: WiFi连接状态变化
- `MQTT_STATE_CHANGE`: MQTT连接状态变化
- `SYSTEM_STATE_CHANGE`: 系统状态转换
- `SYSTEM_ERROR`: 系统错误事件
- `NTP_STATE_CHANGE`: 时间同步状态

### 事件流转路径
```
WiFi连接成功 → WIFI_STATE_CHANGE → FSM状态转换 → LED指示更新
MQTT断开 → MQTT_STATE_CHANGE → NetworkManager重连 → 状态上报
系统错误 → SYSTEM_ERROR → FSM错误处理 → 看门狗重启
```

## 状态转换逻辑

### FSM状态定义
1. **BOOT**: 系统启动，硬件初始化
2. **INIT**: 配置加载，模块初始化
3. **CONNECTING**: 网络连接流程（WiFi → NTP → MQTT）
4. **RUNNING**: 正常运行，业务逻辑执行
5. **ERROR**: 错误状态，等待恢复或重启

### 状态转换条件
- BOOT → INIT: 硬件初始化完成
- INIT → CONNECTING: 配置加载成功，网络模块就绪
- CONNECTING → RUNNING: WiFi + MQTT连接成功（NTP可选）
- * → ERROR: 任意状态遇到致命错误
- ERROR → BOOT: 看门狗超时或手动重启

## 配置管理架构

### 配置文件结构
- **system**: 系统行为配置（调试模式、循环延迟）
- **daemon**: 守护进程配置（LED引脚、看门狗超时）
- **wifi**: WiFi连接配置
- **mqtt**: MQTT服务器配置
- **ntp**: NTP时间同步配置

### 配置访问模式
```python
# 集中式配置管理
config = get_config()
wifi_config = get_config('wifi')
mqtt_broker = get_config('mqtt', 'broker', 'default-broker')
```

## 内存管理策略

### 内存优化措施
1. **延迟加载**: 模块按需导入，减少启动内存占用
2. **垃圾回收**: 主循环中定期调用gc.collect()
3. **对象复用**: 避免频繁创建/销毁临时对象
4. **缓存策略**: WiFi扫描结果缓存，减少重复操作

### 内存监控
- 主循环中定期输出内存使用情况
- 内存不足时触发强制垃圾回收
- 内存告警阈值监控

## 错误处理与恢复

### 分层错误处理
1. **模块级**: 各模块内部的异常捕获与优雅降级
2. **管理器级**: NetworkManager的连接重试与状态恢复
3. **系统级**: FSM的错误状态处理与看门狗保护

### 自动恢复机制
- WiFi连接丢失 → 自动重连
- MQTT断开 → 增量重连（保持WiFi连接）
- 系统死锁 → 看门狗重启
- 内存耗尽 → 强制垃圾回收

## 扩展性设计

### 模块扩展点
1. **传感器模块**: 预留传感器数据采集与上报接口
2. **控制模块**: 支持设备控制指令的接收与执行
3. **存储模块**: 本地数据存储与配置持久化
4. **通信协议**: 支持其他通信协议（CoAP、HTTP）

### 配置扩展
- 新模块配置可直接添加到配置文件
- 动态配置加载与热更新支持
- 配置验证与默认值机制

## 性能特征

### 启动性能
- 冷启动时间: ~3-5秒
- 网络连接时间: ~5-10秒（取决于网络条件）
- 内存占用: 启动后约40-60KB

### 运行性能
- 主循环周期: 50ms（可配置）
- 事件响应延迟: <100ms
- MQTT消息处理: <50ms

### 稳定性指标
- 连续运行时间: >7天（理论值）
- 内存泄漏: 无明显内存增长
- 错误恢复: 90%+自动恢复成功率

## 部署与维护

### 构建流程
```bash
python build.py -c  # 编译并上传到设备
```

### 日志监控
- 分级日志输出（DEBUG/INFO/WARN/ERROR）
- 模块标识与时间戳
- 关键状态转换与性能指标记录

### 维护接口
- 配置文件热更新
- 远程重启指令
- 状态查询与诊断信息