# 优化模块集成建议

## 当前问题分析

通过代码分析发现，项目中的优化模块使用率较低，需要补齐集成闭环与运行时观测。

### StaticCache 使用情况
- 已初始化：在 `main.py` 中创建实例并传递给状态机
- 实际使用：在 `fsm.py` 中用于保存状态信息：
  - `static_cache.set('current_state', new_state)`
  - `static_cache.set('last_state_change', time.ticks_ms())`
  - 在主循环中调用 `static_cache.loop()` 进行防抖写入
- 未充分利用：未用于存储其他需要持久化的配置或状态

### ObjectPool 使用情况
- 已初始化：在 `main.py` 中创建实例并配置了对象池
- 配置的池：`mqtt_messages`, `sensor_data`, `log_messages`, `system_events`
- 实际使用：虽然传递给了 `MqttController` 和 `SensorManager`，但在这些模块中未实际使用 acquire/release

## 优化模块集成计划

### 1. 扩展 StaticCache 使用
- 配置缓存：缓存 WiFi、MQTT 配置，减少重复读取。
- 运行状态：缓存网络连接状态、重连计数、最近一次出错时间等。
- 传感器：缓存最近 N 次读数用于简单统计（min/max/avg）。
- 状态恢复：重启后恢复 FSM 上次稳定状态和关键计数器。

### 2. 落地 ObjectPool（高优先级）
- MQTT 消息：通过对象池复用消息缓冲，发布后归还，避免频繁申请大字符串内存。
- 传感器数据：采样结构对象复用，减少临时字典/元组创建。
- 事件总线：事件载体对象复用，减轻高频事件时 GC 压力。
- 日志系统：日志条目对象复用或复用字符串缓冲，配合批量输出（可选）。

### 3. 性能监控与可视化
- 内存：周期性记录 `gc.mem_free()` 和 `gc.mem_alloc()`；在日志中以固定频率输出。
- 对象池：统计 acquire/release 次数、命中率、扩容次数、失败次数。
- 事件：记录单位时间内事件发布与处理量，识别热点。

### 4. 代码重构要点（不引入新文件，优先重用现有模块）
- 将频繁创建的字典、字符串改为使用对象池提供的可复用结构。
- 事件处理路径减少临时闭包/lambda，优先使用已定义函数。
- 在 `logger`/`mqtt`/`sensor` 内保持统一的日志/错误处理风格，便于排查。

## 分阶段实施路径
1) 先在 MQTT 与 Sensor 中接入对象池（acquire -> 填充 -> 使用 -> release）。
2) 将 FSM 与网络状态写入 StaticCache，并在启动阶段读取恢复。
3) 加入性能指标与周期性日志，观察并调参（对象池容量、写回周期等）。

## 验收标准
- 峰值内存占用下降，GC 触发频率降低（至少下降 20%）。
- 高频场景（连续消息发布、快速采样）下，不出现碎片化导致的软重启。
- 系统重启后，能恢复关键状态（FSM、网络统计）。

## 任务拆解清单（可直接执行）
- 在 `app/net/mqtt.py` 中：
  - 使用对象池创建/复用消息缓冲；发布后释放。
  - 增加简易发送队列上限与丢弃统计，输出 WARN 日志。
- 在 `app/hw/sensor.py` 中：
  - 采集数据结构改为对象池复用；批量上报时统一释放。
- 在 `app/lib/event_bus.py` 中：
  - 事件对象（如元组/字典）统一走对象池；发布后归还。
- 在 `app/lib/logger.py` 中：
  - 可选：为格式化字符串提供预分配缓冲；或最小化 format 调用。
- 在 `app/fsm.py` 与 `app/main.py` 中：
  - 将网络/状态统计写入 StaticCache，并在启动时恢复。

## 备注
- 遵循“先实现基础功能，再优化”的原则，逐步引入，随改随测。
- 不新增文件，尽量在现有模块内重构与集成，以保证结构简洁。