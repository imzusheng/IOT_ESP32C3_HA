# -*- coding: utf-8 -*-
"""
配置模块

所有配置项都在此文件中直接定义，并附有详细说明。
通过 `get_config()` 函数可以安全地访问这些配置。
要修改配置，直接编辑下面的 CONFIG 字典即可。
注释旨在帮助理解每个参数的用途、对项目的影响以及推荐的设定范围。
"""

import gc

# =============================================================================
# 配置数据 (唯一配置源)
# =============================================================================

CONFIG = {
    "mqtt": {
        # 描述: MQTT服务器的IP地址或域名。
        # 影响: 这是设备与MQTT代理通信的核心地址。如果错误，设备将无法连接到消息服务器，所有远程通信功能将失效。
        # 建议: 推荐使用内网的静态IP地址，例如 "192.168.3.15"。
        "broker": "192.168.3.15",

        # 描述: MQTT服务器的端口号。
        # 影响: 必须与服务器配置的端口完全一致，否则无法建立TCP连接。
        # 建议: 标准端口为 `1883`，使用TLS/SSL加密时通常为 `8883`。
        "port": 1883,

        # 描述: 设备发布和订阅消息的基础主题(Topic)。
        # 影响: 定义了设备在MQTT网络中的"通信频道"。应确保其唯一性，以防与其他设备发生消息错乱。
        # 建议: 采用层级结构，如 "iot_project/living_room/esp32_sensor_1"。
        "topic": "lzs/esp32c3",

        # 描述: MQTT连接的保活心跳时间，单位为秒。
        # 影响: 设备会按此周期向服务器发送心跳包以维持连接。值太小会增加网络流量；值太大会导致服务器延迟发现设备离线。
        # 建议: 30-120 秒。
        "keepalive": 60,

        # 描述: MQTT连接断开后，尝试重连的等待时间，单位为秒。
        # 影响: 决定了网络波动或服务器重启后，设备恢复连接的速度。设置过短可能在网络未稳定时频繁重试。
        # 建议: 3-10 秒。
        "reconnect_delay": 5,

        # 描述: MQTT连接失败后的最大重试次数。
        # 影响: 限制了在持续无法连接的情况下，设备尝试重连的次数，防止无限重试消耗资源。超过次数后可能会进入某种错误状态或重启。
        # 建议: 3-5 次。
        "max_retries": 3,

        # 描述: 是否启用指数退避策略。
        # 影响: 启用后，重连间隔会按指数增长，避免频繁重试消耗资源和服务器压力。
        # 建议: True（启用）。
        "exponential_backoff": True,

        # 描述: 指数退避的最大等待时间，单位为秒。
        # 影响: 限制了退避时间的最大值，避免等待时间过长影响服务恢复。
        # 建议: 300-600 秒（5-10分钟）。
        "max_backoff_time": 300,

        # 描述: 指数退避的倍数因子。
        # 影响: 决定了退避时间增长的速度，值越大增长越快。
        # 建议: 2-3（2的幂次增长是常见策略）。
        "backoff_multiplier": 2
    },
    "wifi": {
        # 描述: WiFi网络列表，设备将按从上到下的顺序尝试连接。
        # 影响: 这是设备接入网络的基础。如果列表为空或所有网络都无法连接，设备将处于离线状态。
        # 建议: 将最稳定或最常用的WiFi网络放在列表的最前面。
        "networks": [
            {"ssid": "zsm60p", "password": "25845600"},
            {"ssid": "leju_software", "password": "leju123456"}
        ],

        # 描述: 连接单个WiFi网络时允许的最大超时时间，单位为秒。
        # 影响: 时间太短可能在信号弱时连接失败；时间太长会增加设备在网络不可用时的总等待时间。
        # 建议: 10-30 秒。
        "timeout": 15,

        # 描述: 在未连接状态下，定期扫描可用WiFi网络的间隔，单位为秒。
        # 影响: 决定了设备发现新的可用网络或已配置网络恢复的速度。
        # 建议: 30-60 秒。
        "scan_interval": 30,

        # 描述: 连接单个WiFi失败后，再次尝试连接的等待时间，单位为秒。
        # 影响: 为网络或路由器提供一个短暂的恢复时间。
        # 建议: 2-5 秒。
        "retry_delay": 2,

        # 描述: 对单个WiFi网络进行连接尝试的最大次数。
        # 影响: 避免对一个持续无效的网络进行过多无效尝试，从而能更快地切换到列表中的下一个网络。
        # 建议: 3-5 次。
        "max_attempts": 3
    },
    "daemon": {
        # 描述: 用于状态指示的LED硬件引脚列表。
        # 影响: 必须与实际硬件电路连接的GPIO引脚一致。程序会通过控制这些引脚的电平来指示设备状态（如：启动中、连接中、运行正常、错误）。
        # 建议: 根据您的电路板设计填写，例如 `[12, 13]`。
        "led_pins": [12, 13],

        # 描述: 系统内部使用的定时器ID。
        # 影响: ESP32有多路硬件定时器，选择一个未被其他关键任务（如PWM）占用的ID。
        # 建议: 0-3 之间的整数。
        "timer_id": 0,

        # 描述: 系统状态（CPU温度、内存使用率）监控的频率，单位为毫秒。
        # 影响: 频率越高，系统状态数据更新越及时，但也会轻微增加CPU负担。
        # 建议: 1000-10000 毫秒。
        "monitor_interval": 5000,

        # 描述: CPU核心温度警告阈值，单位为摄氏度。
        # 影响: 当温度超过此值时，系统可能会触发降频、发送警报或进入安全模式以防止硬件过热损坏。
        # 建议: 60-80 摄氏度，取决于具体芯片型号和散热条件。
        "temp_threshold": 65,
        
        # 描述: 温度恢复的迟滞值。温度需降至 (阈值 - 迟滞值) 以下，警报才会解除。
        # 影响: 防止温度在阈值附近小幅波动时，频繁地触发和解除警报。
        # 建议: 3-10 摄氏度。
        "temp_hysteresis": 5,

        # 描述: 内存使用率警告阈值，单位为百分比。
        # 影响: 超过此阈值可能预示着内存泄漏或系统负载过高，可触发警报或强制执行垃圾回收。
        # 建议: 70-90 (%)。
        "memory_threshold": 80,

        # 描述: 内存使用率恢复的迟滞值。
        # 影响: 防止内存使用率在阈值附近波动时，频繁触发和解除警报。
        # 建议: 5-15 (%)。
        "memory_hysteresis": 10,
        
        # 描述: 系统在进入安全模式或重启前，允许累计的最大错误次数。
        # 影响: 这是一个容错机制，避免因为瞬时或小概率的错误导致系统频繁重启。
        # 建议: 5-20 次。
        "max_error_count": 10,

        # 描述: 进入安全模式后的冷却（持续）时间，单位为毫秒。
        # 影响: 在此期间，设备可能只运行最核心的功能，等待系统稳定。
        # 建议: 30000-120000 毫秒。
        "safe_mode_cooldown": 60000,

        # 描述: 看门狗定时器(WDT)的超时时间，单位为毫秒。
        # 影响: 如果主程序在指定时间内没有"喂狗"(feed)，看门狗将强制重启设备。这是防止固件死锁或主循环卡死的最后防线。
        # 建议: 60000-300000 毫秒，必须远大于主循环的正常执行时间。
        "wdt_timeout": 120000,

        # 描述: 是否启用硬件看门狗。
        # 影响: 生产环境中强烈建议启用，以保证设备在无人值守的情况下能从未知错误中自愈。开发调试时可关闭。
        # 建议: 生产环境 `True`，开发环境 `False`。
        "wdt_enabled": True,

        # 描述: 触发强制垃圾回收(GC)的内存使用率阈值，单位为百分比。
        # 影响: 当内存使用率达到这个极高水平时，系统会主动进行一次完整的垃圾回收，以尝试释放内存，避免内存溢出。
        # 建议: 90-98 (%)。
        "gc_force_threshold": 95
    },
    "system": {
        # 描述: 系统调试模式开关。
        # 影响: 开启后通常会通过串口输出更详细的日志信息，便于开发和排错。生产环境中关闭可减少资源消耗并避免暴露敏感信息。
        # 建议: 开发时 `True`，生产环境 `False`。
        "debug_mode": False,

        # 描述: 控制日志输出的最低级别。
        # 影响: 决定了日志的详细程度。`DEBUG`最详细，`CRITICAL`信息最少。生产环境设为`INFO`或`WARNING`可减少不必要的日志刷屏。
        # 建议: "DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"。
        "log_level": "INFO",

        # 描述: 主循环(main loop)的延迟时间，单位为毫秒。
        # 影响: 这是主循环每次迭代的间隔，直接影响系统的响应速度和CPU使用率。值越小响应越快，但CPU占用越高，也越耗电。
        # 建议: 100-1000 毫秒。
        "main_loop_delay": 300,

        # 描述: 通过MQTT或其他方式上报设备状态的周期，单位为主循环次数。
        # 影响: 决定了后端或监控平台接收设备状态（如温度、内存、信号强度等）的频率。
        # 实际间隔 = status_report_interval × main_loop_delay
        # 例如: 50次 × 300ms = 15秒
        # 建议: 30-100 次循环。
        "status_report_interval": 50,

        # 描述: 是否在发生严重错误时启用自动重启功能。
        # 影响: 开启后，当系统检测到无法恢复的严重错误时，会主动重启，尝试恢复正常。这是提高系统可用性的重要手段。
        # 建议: 生产环境 `True`。
        "auto_restart_enabled": False
    },
    "device": {
        # 描述: 设备的名称或标识符。
        # 影响: 主要用于在网络、日志或管理平台中识别此设备。
        # 建议: 使用一个有意义且唯一的名称，如 "ESP32C3-LivingRoom"。
        "name": "ESP32C3-IOT",

        # 描述: 设备的物理位置描述。
        # 影响: 便于资产管理和问题排查，尤其是在部署了大量设备时。
        # 建议: 例如 "客厅", "服务器机房A-3架"。
        "location": "未知位置",

        # 描述: 当前设备的固件版本号。
        # 影响: 用于版本管理、问题追踪和OTA（空中升级）流程。
        # 建议: 遵循语义化版本规范，如 "1.0.0"。
        "firmware_version": "1.0.0"
    }
}


# =============================================================================
# 配置访问接口
# =============================================================================

def get_config(section: str = None, key: str = None, default=None):
    """
    从模块内部的 CONFIG 字典中安全地获取配置值。

    Args:
        section (str, optional): 配置段名称。如果为None，返回整个配置字典。
        key (str, optional): 配置键名。如果为None，返回整个配置段。
        default: 默认值，当指定的键不存在时返回。

    Returns:
        配置值或配置字典。
    """
    if section is None:
        return CONFIG

    section_data = CONFIG.get(section, {})

    if key is None:
        return section_data

    return section_data.get(key, default)

# =============================================================================
# 初始化
# =============================================================================

gc.collect()

print("[Config] Configuration module loaded.")